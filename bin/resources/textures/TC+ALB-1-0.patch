Index: Beam.cpp
===================================================================
--- Beam.cpp	(revision 1264)
+++ Beam.cpp	(working copy)
@@ -410,6 +410,13 @@
 	else
 		driveable=NOT_DRIVEABLE;
 	previousGear = 0;
+	alb_ratio = alb_minspeed = alb_mode = 0.0f;
+	tc_ratio = tc_fade = tc_mode = tc_wheelslip = 0.0f;
+	tc_pulse = 1;
+	alb_pulse = 1;
+	tc_present = alb_present = alb_notoggle = false;
+	tc_pulse_state = alb_pulse_state = alb_notoggle = false;
+	tcalb_timer = 0.0f;
 	previousCrank = 0.0f;
 	animTimer = 0.0f;
 	engine=0;
@@ -468,6 +475,8 @@
 	hashelp=0;
 	totalmass=0;
 	parkingbrake=0;
+	antilockbrake = 0;
+	tractioncontrol = 0;
 	lights=1;
 	free_node=0;
 	free_beam=0;
@@ -1546,6 +1555,216 @@
 		if(!strcmp("slidenode_connect_instantly", line))
 			slideNodesConnectInstantly=true;
 
+		if (!strncmp("AntiLockBrakes", line, 14))
+		{
+			float ratio = -1.0f;
+			// parse the line
+			if(String(line).size() < 25)
+			{
+				LogManager::getSingleton().logMessage("Error parsing File (Antilockbrakes) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Not enough Options parsed, trying to continue ...");
+				continue;
+			}
+			std::vector<Ogre::String> options = Ogre::StringUtil::split(String(line).substr(15), ","); // "AntiLockBrakes " = 15 characters
+			// check for common errors
+			if (options.size() < 2)
+			{
+				LogManager::getSingleton().logMessage("Error parsing File (Antilockbrakes) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Not enough Options parsed, trying to continue ...");
+				continue;
+			}
+
+			for(unsigned int i=0;i<options.size();i++)
+			{
+				if(i == 0)
+				{
+					ratio = StringConverter::parseReal(options[i]);
+					//set ratio
+					if (ratio)
+						alb_ratio = ratio;
+						if (alb_ratio < 0.0f) alb_ratio = 0.0f;
+						if (alb_ratio > 20.0f) alb_ratio = 20.0f;
+					else
+					{
+						LogManager::getSingleton().logMessage("Error parsing File (Antilockbrakes) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Mode not parsed, trying to continue....");
+						continue;
+					}
+				} else if(i == 1)
+				{
+					// wheelspeed adaption
+					alb_minspeed = (StringConverter::parseReal(options[i])/3.6f);
+					if (alb_minspeed < 0.5f) alb_minspeed = 0.5f;
+
+				} else if(i == 2)
+				{
+					float pulse = (StringConverter::parseReal(options[i]));
+					if (!pulse)
+						alb_pulse=1.0f;
+					else
+					{
+						alb_pulse = int(2000.0f / fabs(pulse));
+						if (alb_pulse <= 1)
+							alb_pulse = 1;
+					}
+				} else
+				{
+					// parse the rest
+					std::vector<Ogre::String> args2 = Ogre::StringUtil::split(options[i], ":");
+					if(args2.size() == 0)
+					{
+						LogManager::getSingleton().logMessage("Error parsing File (Antilockbrakes) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Antilockbrakes disabeld.");
+						continue;
+					}
+
+					
+					// trim spaces from the entry
+					Ogre::StringUtil::trim(args2[0]);
+					if(args2.size() >= 2) Ogre::StringUtil::trim(args2[1]);
+
+					if(args2[0] == "mode" && args2.size() == 2)
+					{
+						//set source identification flag
+						std::vector<Ogre::String> args3 = Ogre::StringUtil::split(args2[1], "&");
+						for(unsigned int j=0;j<args3.size();j++)
+						{
+							String sourceStr = args3[j];
+							Ogre::StringUtil::trim(sourceStr);
+							if (sourceStr == "ON" || sourceStr == "on")	
+							{
+								alb_mode = 1.0f;
+								alb_present = true;
+							}
+							else if (sourceStr == "OFF" || sourceStr == "off")
+							{ 
+								alb_mode = 0.0f;
+								alb_present = true;
+							}
+							else if (sourceStr == "NODASH" || sourceStr == "nodash" || sourceStr == "Nodash" || sourceStr == "NoDash")
+							{ 
+								alb_present = false;
+							}
+							else if (sourceStr == "NOTOGGLE" || sourceStr == "notoggle" || sourceStr == "Notoggle" || sourceStr == "NoToggle")
+							{ 
+								alb_notoggle = true;
+							}
+
+						}
+
+					} else
+					{
+						LogManager::getSingleton().logMessage("Antilockbrakes Mode: missing " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Antilockbrakes Mode = ON.");
+						alb_present = true;
+						alb_mode = 1.0f;
+					}
+				}
+			}
+			continue;
+		}
+
+		if (!strncmp("TractionControl", line, 15))
+		{
+			float ratio = 0.0f;
+			// parse the line
+			if(String(line).size() < 16)
+			{
+				LogManager::getSingleton().logMessage("Error parsing File (TractionControl) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Not enough Options parsed, trying to continue ...");
+				continue;
+			}
+			std::vector<Ogre::String> options = Ogre::StringUtil::split(String(line).substr(16), ","); // "TractionControl " = 16 characters
+			// check for common errors
+			if (options.size() < 2)
+			{
+				LogManager::getSingleton().logMessage("Error parsing File (TractionControl) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Not enough Options parsed, trying to continue ...");
+				continue;
+			}
+
+			for(unsigned int i=0;i<options.size();i++)
+			{
+				if(i == 0)
+				{
+					ratio = StringConverter::parseReal(options[i]);
+					//set ratio
+					if (ratio)
+						tc_ratio = ratio;
+						if (tc_ratio < 0.0f) tc_ratio = 0.0f;
+						if (tc_ratio > 20.0f) tc_ratio = 20.0f;
+					else
+						LogManager::getSingleton().logMessage("Error parsing File (TractionControl) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". TractionControl disabeld.");
+				} else if(i == 1)
+				{
+					tc_wheelslip = (StringConverter::parseReal(options[i]));
+					if (tc_wheelslip < 0.0f) tc_wheelslip = 0.0f;
+				} else if(i == 2)
+				{
+					// wheelspeed adaption
+					tc_fade = (StringConverter::parseReal(options[i]));
+					if (tc_fade <= 0.1f) tc_fade = 0.1f;
+
+				} else if(i == 3)
+				{
+					float pulse = (StringConverter::parseReal(options[i]));
+					if (!pulse)
+						tc_pulse=1;
+					else
+					{
+						tc_pulse = int( 2000.0f / fabs(pulse));
+						if (tc_pulse <= 1) 
+							tc_pulse = 1;
+					}
+				} else
+				{
+					// parse the rest
+					std::vector<Ogre::String> args2 = Ogre::StringUtil::split(options[i], ":");
+					if(args2.size() == 0)
+					{
+						LogManager::getSingleton().logMessage("Error parsing File (TractionControl) " + String(fname) +" line " + StringConverter::toString(linecounter) + ". Mode not parsed, trying to continue....");
+						continue;
+					}
+
+					
+					// trim spaces from the entry
+					Ogre::StringUtil::trim(args2[0]);
+					if(args2.size() >= 2) Ogre::StringUtil::trim(args2[1]);
+
+					if(args2[0] == "mode" && args2.size() == 2)
+					{
+						//set source identification flag
+						std::vector<Ogre::String> args3 = Ogre::StringUtil::split(args2[1], "&");
+						for(unsigned int j=0;j<args3.size();j++)
+						{
+							String sourceStr = args3[j];
+							Ogre::StringUtil::trim(sourceStr);
+							if (sourceStr == "ON" || sourceStr == "on" || sourceStr == "On")	
+							{ 
+								tc_mode = 1.0f;
+								tc_present = true;
+							}
+							else if (sourceStr == "OFF" || sourceStr == "off" || sourceStr == "Off")
+							{ 
+								tc_mode = 0.0f;
+								tc_present = true;
+							}
+							else if (sourceStr == "NODASH" || sourceStr == "nodash" || sourceStr == "Nodash" || sourceStr == "NoDash")
+							{ 
+								tc_present = false;
+							}
+							else if (sourceStr == "NOTOGGLE" || sourceStr == "notoggle" || sourceStr == "Notoggle" || sourceStr == "NoToggle")
+							{ 
+								tc_notoggle = true;
+							}
+						}
+
+					} else
+					{
+						LogManager::getSingleton().logMessage("TractionControl Mode: missing " + String(fname) +" line " + StringConverter::toString(linecounter) + ". TractionControl Mode = ON.");
+						tc_present = true;
+						tc_mode = 1.0f;
+					}
+				}
+			}
+			continue;
+		}
+
+
+
 		if (!strncmp("add_animation", line, 13))
 		{
 			/*
@@ -5136,6 +5355,12 @@
 	//pump
 	if (hascommands)
 		addSoundSource(ssm->createInstance("tracks/default_pump", trucknum, NULL), 0);
+	//antilock brake
+	if (alb_present)
+		addSoundSource(ssm->createInstance("tracks/default_antilock", trucknum, NULL), 0);
+	//tractioncontrol
+	if (alb_present)
+		addSoundSource(ssm->createInstance("tracks/default_tractioncontrol", trucknum, NULL), 0);
 	//screetch
 	if ((driveable==TRUCK || driveable==AIRPLANE) && free_wheel)
 		addSoundSource(ssm->createInstance("tracks/default_screetch", trucknum, NULL), 0);
@@ -7511,7 +7736,7 @@
 				if (props[propi].animFlags[animnum] & ANIM_FLAG_AILERONS) cstate += hydroaileronstate;
 				//elevator
 				if (props[propi].animFlags[animnum] & ANIM_FLAG_ELEVATORS) cstate += hydroelevatorstate;
-				//rudder Liftec
+				//rudder
 				if (props[propi].animFlags[animnum] & ANIM_FLAG_ARUDDER) cstate += hydrorudderstate;
 				//permanent
 				if (props[propi].animFlags[animnum] & ANIM_FLAG_PERMANENT) cstate += 1.0f;
@@ -8328,6 +8553,33 @@
 		intertorque[axles[i].wheel_2] = diff_data.out_torque[1];
 	}
 
+	//drivingaids pulse 
+	tcalb_timer++;
+	if (tcalb_timer >= 50000) 
+		tcalb_timer = 0;
+	if (tc_pulse == 1)
+		tc_pulse_state = true;
+	else
+		if (tcalb_timer % tc_pulse == 0) tc_pulse_state = !tc_pulse_state;
+	if (alb_pulse == 1)
+		alb_pulse_state = true;
+	else
+		if (tcalb_timer % alb_pulse == 0) alb_pulse_state = !alb_pulse_state;
+
+	//drinving aids active: get current airspeed
+	float airspeed=0.0f;
+	if ((tc_mode || alb_mode) && (tc_pulse_state || alb_pulse_state))
+	{
+		int div = 0;
+		int flagstate = ANIM_FLAG_AIRSPEED;
+		calcAnimators(flagstate, airspeed, div, dt, 0.0f, 0.0f, 0.0f);
+		// -46.67 is the static conversion multiplier airspeed to wheelspeed
+		airspeed = airspeed * -46.67f;
+	}
+
+	bool tc_active=false;
+	bool alb_active=false;
+
 	for (i=0; i<free_wheel; i++)
 	{
 		Real speedacc=0.0;
@@ -8349,16 +8601,54 @@
 			float dbrake=0.0;
 			if (wheels[i].braked==2 && hydrodirstate>0.0 && WheelSpeed<20.0) dbrake=brakeforce*hydrodirstate;
 			if (wheels[i].braked==3 && hydrodirstate<0.0 && WheelSpeed<20.0) dbrake=brakeforce*-hydrodirstate;
-
+			
 			if ((brake != 0.0 || dbrake != 0.0 || hbrake != 0.0) && braked_wheels != 0)
 			{
 				if( fabs(wheels[i].speed) > 0.1f )
-					total_torque -= (wheels[i].speed/fabs(wheels[i].speed))*(brake + dbrake + hbrake);
+				{
+					float antilock_coef = 1.0f;
+					if (alb_mode && alb_pulse_state)
+					{
+						// avoid divide by zero
+						if(!airspeed) airspeed = 0.0001f;
+						antilock_coef = fabs(wheels[i].speed) / airspeed;
+						antilock_coef = pow(antilock_coef,alb_ratio);
+						// avoid backwards acceleration but keep braking
+						if (antilock_coef <= 0) antilock_coef *= -1.0f;
+						//limit brakeforce when wheels are in the air
+						if (antilock_coef > 2.0f) antilock_coef = 2.0f;
+						// no abs under minspeed setting
+						if (airspeed < alb_minspeed) antilock_coef = 1.0f;
+						if (antilock_coef < 0.9 ) alb_active = true;
+					}
+					// dont use to antilock_coef for handbrake
+					total_torque -= ((wheels[i].speed/fabs(wheels[i].speed))*((brake*antilock_coef) + (dbrake*antilock_coef) + hbrake));
+					if (antilock_coef >= 1.0 && antilockbrake) antilockbrake = !antilockbrake;
 				// wheels are stopped, really this should
-				else if( fabs(wheels[i].speed) > 0.0f)
+				} else if( fabs(wheels[i].speed) > 0.0f)
 					total_torque -= (wheels[i].speed/fabs(wheels[i].speed))*(brake + dbrake + hbrake)*1.2;
 			}
 		}
+
+		//traction control
+		if (tc_mode && tc_pulse_state)
+		{
+			if(airspeed < 2.5) airspeed = 2.5f;
+			//set the base wheelslipcoef
+			float wheelslip = tc_wheelslip + 1.0f;
+			// wheelslip allowed doubles up to tc_fade, a tribute to RoRs wheelspeed calculation and frriction
+			wheelslip += (wheelslip*(airspeed/tc_fade));
+			//add wheelslip% as activation offset
+			float torque_coef = (airspeed * wheelslip) / fabs(wheels[i].speed);
+			torque_coef = pow(torque_coef,tc_ratio);
+			// avoid powerboost
+			if (torque_coef > 1.0f) torque_coef = 1.0f;
+			// keep 1% minimum torque
+			if (torque_coef < 0.01f) torque_coef = 0.01f;
+			if (torque_coef < 0.9) tc_active = true;
+			total_torque *= torque_coef;
+		}
+
 		//friction
 		total_torque -= wheels[i].speed*1.0; //it is important to keep some wheel friction to avoid numerical instabilities
 
@@ -8422,6 +8712,29 @@
 			wheels[i].near_attach->Forces+=cforce;
 		}
 	}
+	//dashboard overlays for tc+alb
+	if (!alb_active)
+	{
+		antilockbrake = false;
+		ssm->trigStop(trucknum, SS_TRIG_ALB_ACTIVE);
+	} else
+	{
+		antilockbrake = true;
+		ssm->trigStart(trucknum, SS_TRIG_ALB_ACTIVE);
+	}
+
+
+	if (!tc_active)
+	{
+		tractioncontrol = false;
+		ssm->trigStop(trucknum, SS_TRIG_TC_ACTIVE);
+	} else
+	{
+		tractioncontrol = true;
+		ssm->trigStart(trucknum, SS_TRIG_TC_ACTIVE);
+	}
+
+
 	//LogManager::getSingleton().logMessage("torque "+StringConverter::toString(torques[0])+" "+StringConverter::toString(torques[1])+" "+StringConverter::toString(torques[2])+" "+StringConverter::toString(torques[3])+" speed "+StringConverter::toString(newspeeds[0])+" "+StringConverter::toString(newspeeds[1])+" "+StringConverter::toString(newspeeds[2])+" "+StringConverter::toString(newspeeds[3]));
 	for (i=0; i<free_wheel; i++) wheels[i].speed=newspeeds[i];
 	//wheel speed
@@ -10669,6 +10982,16 @@
 #endif
 }
 
+void Beam::antilockbrakeToggle()
+{
+	alb_mode=!alb_mode;
+}
+
+void Beam::tractioncontrolToggle()
+{
+	tc_mode=!tc_mode;
+}
+
 void Beam::beaconsToggle()
 {
 	bool enableLight = true;
Index: Beam.h
===================================================================
--- Beam.h	(revision 1264)
+++ Beam.h	(working copy)
@@ -43,7 +43,6 @@
 
 #include "SocketW.h"
 #include "rornet.h"
-//#include "OgreTerrainSceneManager.h"
 #include "MovableText.h"
 #include "engine.h"
 #include "networkinfo.h"
@@ -57,6 +56,7 @@
 #include "Streamable.h"
 #include "groundmodel.h"
 #include "rormemory.h"
+#include "rormemory.h"
 #include <vector>
 
 //#include "scriptCommands.h"
@@ -789,6 +789,8 @@
 	void toggleSlideNodeLock( Beam** trucks, int trucksnum, unsigned int curTruck );
 
 	void parkingbrakeToggle();
+	void antilockbrakeToggle();
+	void tractioncontrolToggle();
 	void beaconsToggle();
 	void setReplayMode(bool rm);
 	int savePosition(int position);
@@ -879,6 +881,24 @@
 	int driveable;
 	int previousGear;
 	float previousCrank;
+	float alb_ratio;
+	float alb_minspeed;
+	float alb_mode;
+	unsigned int alb_pulse;
+	bool alb_pulse_state;
+	bool alb_present;
+	bool alb_notoggle;
+	float tc_ratio;
+	float tc_wheelslip;
+	float tc_fade;
+	float tc_mode;
+	unsigned int tc_pulse;
+	bool tc_pulse_state;
+	bool tc_present;
+	bool tc_notoggle;
+	unsigned int tcalb_timer;
+	int antilockbrake;
+	int tractioncontrol;
 	float animTimer;
 	int importcommands;
 	bool requires_wheel_contact;
Index: ExampleFrameListener.cpp
===================================================================
--- ExampleFrameListener.cpp	(revision 1264)
+++ ExampleFrameListener.cpp	(working copy)
@@ -733,7 +733,42 @@
 		else batto->setMaterialName("tracks/batt-off");
 		if (trucks[current_truck]->parkingbrake) pbrakeo->setMaterialName("tracks/pbrake-on");
 		else pbrakeo->setMaterialName("tracks/pbrake-off");
+		
+		if (trucks[current_truck]->tc_present)
+		{
+			if (trucks[current_truck]->tc_mode)
+				if (trucks[current_truck]->tractioncontrol) 
+				{
+					tcontrolo->setMaterialName("tracks/tcontrol-act");
+					} else 
+				{
+					tcontrolo->setMaterialName("tracks/tcontrol-on");
+				}
+			else 
+			{
+				tcontrolo->setMaterialName("tracks/tcontrol-off");
+			}
+		} else
+		{
+			tcontrolo->setMaterialName("tracks/trans");
+		}
 
+		if (trucks[current_truck]->alb_present)
+		{
+			if (trucks[current_truck]->alb_mode)
+				if (trucks[current_truck]->antilockbrake)
+				{
+					antilocko->setMaterialName("tracks/antilock-act");
+				} else 
+				{
+					antilocko->setMaterialName("tracks/antilock-on");
+				}
+			else 
+			{
+				antilocko->setMaterialName("tracks/antilock-off");
+			}
+		} else antilocko->setMaterialName("tracks/trans");
+
 		// TODO: FIX
 		if (trucks[current_truck]->isLocked())
 		{
@@ -1232,6 +1267,8 @@
 	resizePanel(igno=OverlayManager::getSingleton().getOverlayElement("tracks/ign"), win);
 	resizePanel(batto=OverlayManager::getSingleton().getOverlayElement("tracks/batt"), win);
 	resizePanel(pbrakeo=OverlayManager::getSingleton().getOverlayElement("tracks/pbrake"), win);
+	resizePanel(tcontrolo=OverlayManager::getSingleton().getOverlayElement("tracks/tcontrol"), win);
+	resizePanel(antilocko=OverlayManager::getSingleton().getOverlayElement("tracks/antilock"), win);
 	resizePanel(lockedo=OverlayManager::getSingleton().getOverlayElement("tracks/locked"), win);
 	resizePanel(securedo=OverlayManager::getSingleton().getOverlayElement("tracks/secured"), win);
 	resizePanel(lopresso=OverlayManager::getSingleton().getOverlayElement("tracks/lopress"), win);
@@ -3615,6 +3652,19 @@
 						trucks[current_truck]->parkingbrakeToggle();
 					}
 
+					if (INPUTENGINE.getEventBoolValueBounce(EV_TRUCK_ANTILOCK_BRAKE))
+					{
+						if (trucks[current_truck]->alb_present && !trucks[current_truck]->alb_notoggle) 
+						{
+							trucks[current_truck]->antilockbrakeToggle();
+						}
+					}
+
+					if (INPUTENGINE.getEventBoolValueBounce(EV_TRUCK_TRACTION_CONTROL))
+					{
+						if (trucks[current_truck]->tc_present && !trucks[current_truck]->tc_notoggle) trucks[current_truck]->tractioncontrolToggle();
+					}
+
 				}
 				if (trucks[current_truck]->driveable==AIRPLANE)
 				{
Index: ExampleFrameListener.h
===================================================================
--- ExampleFrameListener.h	(revision 1264)
+++ ExampleFrameListener.h	(working copy)
@@ -302,6 +302,8 @@
 	*/
 
 	OverlayElement *pbrakeo;
+	OverlayElement *tcontrolo;
+	OverlayElement *antilocko;
 	OverlayElement *lockedo;
 	OverlayElement *securedo;
 	OverlayElement *lopresso;
Index: InputEngine.cpp
===================================================================
--- InputEngine.cpp	(revision 1264)
+++ InputEngine.cpp	(working copy)
@@ -1097,6 +1097,18 @@
 		"Keyboard P",
 		_L("toggle parking brake")
 	},
+		{
+		"TRUCK_ANTILOCK_BRAKE",
+		EV_TRUCK_ANTILOCK_BRAKE,
+		"Keyboard EXPL+SHIFT+B",
+		_L("toggle antilock brake")
+	},
+		{
+		"TRUCK_TRACTION_CONTROL",
+		EV_TRUCK_TRACTION_CONTROL,
+		"Keyboard EXPL+SHIFT+T",
+		_L("toggle traction control")
+	},
 	{
 		"TRUCK_SHIFT_DOWN",
 		EV_TRUCK_SHIFT_DOWN,
Index: InputEngine.h
===================================================================
--- InputEngine.h	(revision 1264)
+++ InputEngine.h	(working copy)
@@ -258,6 +258,8 @@
 	EV_TRUCK_LIGHTTOGGLE10, //!< toggle custom light 10
 	EV_TRUCK_MANUAL_CLUTCH, //!< manual clutch (for manual transmission)
 	EV_TRUCK_PARKING_BRAKE, //!< toggle parking brake
+	EV_TRUCK_ANTILOCK_BRAKE, //!< toggle antilockbrake system
+	EV_TRUCK_TRACTION_CONTROL, //!< toggle antilockbrake system
 	EV_TRUCK_SHIFT_DOWN, //!< shift one gear down in manual transmission mode
 	EV_TRUCK_SHIFT_NEUTRAL, //!< shift to neutral gear in manual transmission mode
 	EV_TRUCK_SHIFT_UP, //!< shift one gear up in manual transmission mode
Index: ScriptEngine.cpp
===================================================================
--- ScriptEngine.cpp	(revision 1264)
+++ ScriptEngine.cpp	(working copy)
@@ -270,6 +270,8 @@
 	result = engine->RegisterObjectMethod("BeamClass", "void showSkeleton(bool, bool)", asMETHOD(Beam,showSkeleton), asCALL_THISCALL); assert(result>=0);
 	result = engine->RegisterObjectMethod("BeamClass", "void hideSkeleton(bool)", asMETHOD(Beam,hideSkeleton), asCALL_THISCALL); assert(result>=0);
 	result = engine->RegisterObjectMethod("BeamClass", "void parkingbrakeToggle()", asMETHOD(Beam,parkingbrakeToggle), asCALL_THISCALL); assert(result>=0);
+	result = engine->RegisterObjectMethod("BeamClass", "void tractioncontrolToggle())", asMETHOD(Beam,tractioncontrolToggle), asCALL_THISCALL); assert(result>=0);
+	result = engine->RegisterObjectMethod("BeamClass", "void antilockbrakeToggle()", asMETHOD(Beam,antilockbrakeToggle), asCALL_THISCALL); assert(result>=0);
 	result = engine->RegisterObjectMethod("BeamClass", "void beaconsToggle()", asMETHOD(Beam,beaconsToggle), asCALL_THISCALL); assert(result>=0);
 	result = engine->RegisterObjectMethod("BeamClass", "void setReplayMode(bool)", asMETHOD(Beam,setReplayMode), asCALL_THISCALL); assert(result>=0);
 	result = engine->RegisterObjectMethod("BeamClass", "void resetAutopilot()", asMETHOD(Beam,resetAutopilot), asCALL_THISCALL); assert(result>=0);
@@ -331,6 +333,8 @@
 	result = engine->RegisterObjectProperty("BeamClass", "bool wheel_contact_requested", offsetof(Beam, wheel_contact_requested)); assert(result>=0);
 	result = engine->RegisterObjectProperty("BeamClass", "bool rescuer", offsetof(Beam, rescuer)); assert(result>=0);
 	result = engine->RegisterObjectProperty("BeamClass", "int parkingbrake", offsetof(Beam, parkingbrake)); assert(result>=0);
+	result = engine->RegisterObjectMethod("BeamClass", "void tractioncontrolToggle())", asMETHOD(Beam,tractioncontrolToggle), asCALL_THISCALL); assert(result>=0);
+	result = engine->RegisterObjectMethod("BeamClass", "void antilockbrakeToggle()", asMETHOD(Beam,antilockbrakeToggle), asCALL_THISCALL); assert(result>=0);
 	result = engine->RegisterObjectProperty("BeamClass", "int lights", offsetof(Beam, lights)); assert(result>=0);
 	result = engine->RegisterObjectProperty("BeamClass", "int smokeId", offsetof(Beam, smokeId)); assert(result>=0);
 	result = engine->RegisterObjectProperty("BeamClass", "int editorId", offsetof(Beam, editorId)); assert(result>=0);
@@ -510,6 +514,8 @@
 	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_SKELETON_TOGGLE", SE_TRUCK_SKELETON_TOGGLE); assert(result>=0);
 	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_TIE_TOGGLE", SE_TRUCK_TIE_TOGGLE); assert(result>=0);
 	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_PARKINGBREAK_TOGGLE", SE_TRUCK_PARKINGBREAK_TOGGLE); assert(result>=0);
+	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_TRACTIONCONTROL_TOGGLE", SE_TRUCK_TRACTIONCONTROL_TOGGLE); assert(result>=0);
+	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_ANTILOCKBRAKE_TOGGLE", SE_TRUCK_ANTILOCKBRAKE_TOGGLE); assert(result>=0);
 	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_BEACONS_TOGGLE", SE_TRUCK_BEACONS_TOGGLE); assert(result>=0);
 	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_CPARTICLES_TOGGLE", SE_TRUCK_CPARTICLES_TOGGLE); assert(result>=0);
 	result = engine->RegisterEnumValue("scriptEvents", "SE_TRUCK_GROUND_CONTACT_CHANGED", SE_TRUCK_GROUND_CONTACT_CHANGED); assert(result>=0);
Index: ScriptEngine.h
===================================================================
--- ScriptEngine.h	(revision 1264)
+++ ScriptEngine.h	(working copy)
@@ -100,6 +100,8 @@
 		SE_GENERIC_INPUT_EVENT             = 0x00080000, //!< triggered when an input event bound to the scripting engine is toggled, the argument refers to event id
 		SE_GENERIC_MOUSE_BEAM_INTERACTION  = 0x00100000, //!< triggered when the user uses the mouse to interact with the truck, the argument refers to the truck number
 
+		SE_TRUCK_TRACTIONCONTROL_TOGGLE    = 0x00200000, //!< triggered when the user toggles the tractioncontrol system, the argument refers to the truck number
+		SE_TRUCK_ANTILOCKBRAKE_TOGGLE      = 0x00400000, //!< triggered when the user toggles the antilockbrake, the argument refers to the truck number
 	};
 	
 	unsigned int eventMask;                              //!< filter mask for script events
Index: SoundScriptManager.cpp
===================================================================
--- SoundScriptManager.cpp	(revision 1264)
+++ SoundScriptManager.cpp	(working copy)
@@ -334,6 +334,8 @@
 		if (vec[1]==String("horn")) {trigger_source=SS_TRIG_HORN;return true;};
 		if (vec[1]==String("brake")) {trigger_source=SS_TRIG_BRAKE;return true;};
 		if (vec[1]==String("pump")) {trigger_source=SS_TRIG_PUMP;return true;};
+		if (vec[1]==String("antilock")) {trigger_source=SS_TRIG_ALB_ACTIVE;return true;};
+		if (vec[1]==String("tractioncontrol")) {trigger_source=SS_TRIG_TC_ACTIVE;return true;};
 		if (vec[1]==String("starter")) {trigger_source=SS_TRIG_STARTER;return true;};
 		if (vec[1]==String("always_on")) {trigger_source=SS_TRIG_ALWAYSON;return true;};
 		if (vec[1]==String("repair")) {trigger_source=SS_TRIG_REPAIR;return true;};
Index: SoundScriptManager.h
===================================================================
--- SoundScriptManager.h	(revision 1264)
+++ SoundScriptManager.h	(working copy)
@@ -79,7 +79,9 @@
 #define SS_TRIG_IGNITION	41
 #define SS_TRIG_REVERSE_GEAR 42
 #define SS_TRIG_TURN_SIGNAL  43
-#define SS_MAX_TRIG			44
+#define SS_TRIG_ALB_ACTIVE  44	
+#define SS_TRIG_TC_ACTIVE  45	
+#define SS_MAX_TRIG			46
 
 //list of modulation sources
 #define SS_MOD_NONE			0
